{
  "name": "model",
  "description": "Datastore-agnostic ORM in JavaScript",
  "keywords": [
    "model",
    "orm",
    "relation",
    "data",
    "mapper",
    "validation",
    "postgresql",
    "postgres",
    "riak",
    "mongo",
    "mongodb"
  ],
  "version": "0.2.2",
  "author": {
    "name": "Matthew Eernisse",
    "email": "mde@fleegix.org",
    "url": "http://fleegix.org"
  },
  "main": "./lib/index.js",
  "scripts": {
    "test": "jake test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mde/model.git"
  },
  "dependencies": {
    "utilities": "0.0.x",
    "mongodb-wrapper": "0.4.x",
    "pg": "0.9.x"
  },
  "devDependencies": {
    "jake": "0.5.x"
  },
  "engines": {
    "node": "*"
  },
  "readme": "Model\n==============\n\n[![Build Status](https://travis-ci.org/mde/model.png?branch=master)](https://travis-ci.org/mde/model)\n\nModel is a datastore-agnostic ORM in JavaScript. It serves as the\nmodel-component for the [Geddy MVC Web framework](http://geddyjs.org/) for\nNodeJS.\n\n## Overview\n\nModel currently implements adapters for:\n\n* Postgres\n* Riak\n* MongoDB\n\n### License\n\nApache License, Version 2\n\n### Prerequisites\n\nModel requires version 0.6.x of Node.js or higher. If you want to run the tests,\nor work on Model, you'll want the [Jake](https://github.com/mde/jake) JavaScript\nbuild-tool.\n\n### Installing with [NPM](http://npmjs.org/)\n\n```\nnpm install model\n```\n\n### Hacking on Model: running tests\n\nRun the tests with `jake test`. Run only unit tests with `jake test[unit]`.\n\nThe integration tests require mongo and postgres. To run the tests on a specific\nadapter, use `jake test[mongo]`, `jake test[postgres]`, or `jake test[memory]`.\n\nConfigure adapter options by creating a `test/db.json` file. See\n`test/db.sample.json` for available options.\n\n## Defining models\n\nModel uses a pretty simple syntax for defining a model. (It should look familiar\nto anyone who has used an ORM like ActiveRecord, DataMapper, Django's models, or\nSQLAlchemy.)\n\n```javascript\nvar User = function () {\n  this.property('login', 'string', {required: true});\n  this.property('password', 'string', {required: true});\n  this.property('lastName', 'string');\n  this.property('firstName', 'string');\n\n  this.validatesPresent('login');\n  this.validatesFormat('login', /[a-z]+/, {message: 'Subdivisions!'});\n  this.validatesLength('login', {min: 3});\n  this.validatesConfirmed('password', 'confirmPassword');\n  this.validatesWithFunction('password', function (s) {\n      // Something that returns true or false\n      return s.length > 0;\n  });\n\n  // Can define methods for instances like this\n  this.someMethod = function () {\n    // Do some stuff\n  };\n};\n\n// Can also define them on the prototype\nUser.prototype.someOtherMethod = function () {\n  // Do some other stuff\n};\n\nUser = model.register('User', User);\n```\n\n### Abbreviated syntax\n\nAlternatively, you can use the `defineProperties` method to lay out your model's\nproperties in one go:\n\n```javascript\nvar User = function () {\n  this.defineProperties({\n    login: {type: 'string', required: true}\n  , password: {type: 'string', required: true}\n  , lastName: {type: 'string'}\n  , firstName: {type: 'string'}\n  });\n}\n```\n\n### Datatypes\n\nModel supports the following datatypes:\n\n* string\n* text\n* number\n* int\n* boolean\n* date\n* datetime\n* time\n* object\n\n## Creating instances\n\nCreating an instance of one of these models is easy:\n\n```javascript\nvar params = {\n  login: 'alex'\n, password: 'lerxst'\n, lastName: 'Lifeson'\n, firstName: 'Alex'\n};\nvar user = User.create(params);\n```\n\n## Validations\n\nValidations provide a nice API for making sure your data items are in a good\nstate. When an item is \"valid,\" it means that its data meet all the criteria\nyou've set for it. You can specify that certain fields have to be present, have\nto be certain length, or meet any other specific criteria you want to set.\n\nHere's a list of supported validation methods:\n\n * validatesPresent -- ensures the property exists\n * validatesAbsent -- ensures the property does not exist\n * validatesLength -- ensures the minimum, maximum, or exact length\n * validatesFormat -- validates using a passed-in regex\n * validatesConfirmed -- validates a match against another named parameter\n * validatesWithFunction -- uses an arbitrary function to validate\n\n#### Common options\n\nYou can specify a custom error message for when a validation fails using the\n'message' option:\n\n```javascript\nvar Zerb = function () {\n  this.property('name', 'string');\n  this.validatesLength('name', {is: 3, message: 'Try again, gotta be 3!'});\n};\n```\n\nYou can decide when you want validations to run by passing the 'on' option.\n\n```javascript\nvar User = function () {\n  this.property('name', 'string', {required: false});\n  this.property('password', 'string', {required: false});\n\n  this.validatesLength('name', {min: 3, on: ['create', 'update']});\n  this.validatesPresent('password', {on: 'create'});\n  this.validatesConfirmed('password', 'confirmPassword', {on: 'create'});\n};\n\n// Name validation will pass, but password will fail\nmyUser = User.create({name: 'aaa'});\n\n```\n\nThe default behavior is for validation on both 'create' and 'update':\n\n * `create` - validates on <MyModelDefinition>`.create`\n * `update` - validates on <myModelInstance>`.updateProperties`\n\nYou can also define custom validation scenarios other than create and update.\n(There is a builtin custom 'reify' scenario which is uses when instantiating\nitems out of your datastore. This happens on the `first` and `all` query\nmethods.)\n\n```javascript\n// Force validation with the `reify` scenario, ignore the too-short name property\nmyUser = User.create({name: 'aa'}, {scenario: 'reify'});\n\n// You can also specify a scenario with these methods:\n// Enforce 'create' validations on a fetch -- may result in invalid instances\nUser.first(query, {scenario: 'create'}, cb);\n// Do some special validations you need for credit-card payment\nUser.updateProperties(newAttrs, {scenario: 'creditCardPayment'});\n```\n\n### Validation errors\n\nAny validation errors show up inside an `errors` property on the instance, keyed\nby field name. Instances have an `isValid` method that returns a Boolean\nindicating whether the instance is valid.\n\n```javascript\n// Leaving out the required password field\nvar params = {\n  login: 'alex'\n};\nvar user = User.create(params);\n\n// Prints 'false'\nconsole.log(user.isValid());\n// Prints 'Field \"password\" is required'\nconsole.log(user.errors.password);\n```\n\n## Saving items\n\nAfter creating the instance, call the `save` method on the instance. This method\ntakes a callback in the familiar (err, data) format for Node.\n\n```javascript\nif (user.isValid()) {\n  user.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    console.log('New item saved!');\n  });\n}\n```\n\n## Updating items\n\nUse the `updateProperties` method to update the values of the properties on an\ninstance with the appropriate validations. Then call `save` on the instance.\n\n```javascript\nuser.updateProperties({\n  login: 'alerxst'\n});\nif (user.isValid()) {\n  user.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    console.log('Item updated!');\n  });\n}\n```\n\n## Lifecycle events\n\nBoth the base model 'constructors,' and model instances are EventEmitters. They\nemit events during the create/update/remove lifecycle of model instances. In all\ncases, the plain-named event is fired after the event in question, the\n'before'-prefixed event, of course happens before.\n\nThe 'constructor' for a model emits the following events:\n\n * beforeCreate\n * create\n * beforeValidate\n * validate\n * beforeUpdateProperties\n * updateProperties\n * beforeSave (new instances, single and bulk)\n * save (new instances, single and bulk)\n * beforeUpdate (existing single instances, bulk updates)\n * update (existing single instances, bulk updates)\n * beforeRemove\n * remove\n\nModel-item instances emit these events:\n\n * beforeUpdateProperties\n * updateProperties\n * beforeSave\n * save\n * beforeUpdate\n * update\n\n## Associations\n\nModel has support for associations: including hasMany/belongsTo and\nhasOne/belongsTo. For example, if you had a `User` model with a single\n`Profile`, and potentially many `Accounts`:\n\n```javascript\nvar User = function () {\n  this.property('login', 'string', {required: true});\n  this.property('password', 'string', {required: true});\n  this.property('confirmPassword', 'string', {required: true});\n\n  this.hasOne('Profile');\n  this.hasMany('Accounts');\n};\n```\n\nA `Book` model that belongs to an `Author` would look like this:\n\n```javascript\nvar Book = function () {\n  this.property('title', 'string');\n  this.property('description', 'text');\n\n  this.belongsTo('Author');\n};\n```\n\nAdd the `hasOne` relationship by calling 'set' plus the name of the owned\nmodel in singular (in this case `setProfile`). Retrieve the associated item by\nusing 'get' plus the name of the owned model in singular (in this case\n`getProfile`). Here's an example:\n\n```javascript\nvar user = User.create({\n  login: 'asdf'\n, password: 'zerb'\n, confirmPassword: 'zerb'\n});\nuser.save(function (err, data) {\n  var profile;\n  if (err) {\n    throw err;\n  }\n  profile = Profile.create({});\n  user.setProfile(profile);\n  user.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    user.getProfile(function (err, data) {\n      if (err) {\n        throw err;\n      }\n      console.log(profile.id ' is the same as ' + data.id);\n    });\n  });\n});\n```\n\nSet up the `hasMany` relationship by calling 'add' plus the name of the\nowned model in singular (in this case `addAccount`). Retrieve the associated\nitems with a call to 'get' plus the name of the owned model in plural (in\nthis case `getAccounts`). An example:\n\n```javascript\nvar user = User.create({\n  login: 'asdf'\n, password: 'zerb'\n, confirmPassword: 'zerb'\n});\nuser.save(function (err, data) {\n  if (err) {\n    throw err;\n  }\n  user.addAccount(Account.create({}));\n  user.addAccount(Account.create({}));\n  user.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    user.getAccounts(function (err, data) {\n      if (err) {\n        throw err;\n      }\n      console.log('This number should be 2: ' + data.length);\n    });\n  });\n});\n```\n\nA `belongsTo` relationship is created similarly to a `hasOne`: by calling 'set'\nplus the name of the owner model in singular (in this case `setAuthor`).\nRetrieve the associated item by using 'get' plus the name of the owner model\nin singular (in this case `getAuthor`). Here's an example:\n\n```javascript\nvar book = Book.create({\n  title: 'How to Eat an Entire Ham'\n, description: 'Such a poignant book. I cried.'\n});\nbook.save(function (err, data) {\n  if (err) {\n    throw err;\n  }\n  book.setAuthor(Author.create({\n    familyName: 'Neeble'\n  , givenName: 'Leonard'\n  }));\n  book.save(function (err, data) {\n    if (err) {\n      throw err;\n    }\n    book.getAuthor(function (err, data) {\n      if (err) {\n        throw err;\n      }\n      console.log('This name should be \"Neeble\": ' + data.familyName);\n    });\n  });\n});\n```\n\n### 'Through' associations\n\n'Through' associations allow a model to be associated with another *through* a\nthird model. A good example would be a Team linked to Players through\nMemberships.\n\n```javascript\nvar Player = function () {\n  this.property('familyName', 'string', {required: true});\n  this.property('givenName', 'string', {required: true});\n  this.property('jerseyNumber', 'string', {required: true});\n\n  this.hasMany('Memberships');\n  this.hasMany('Teams', {through: 'Memberships'});\n};\n\nvar Team = function () {\n  this.property('name', 'string', {required: true});\n\n  this.hasMany('Memberships');\n  this.hasMany('Players', {through: 'Memberships'});\n};\n\nvar Membership = function () {\n  this.hasMany('Memberships');\n  this.hasMany('Teams');\n};\n```\n\nThe API for this is the same as with normal associations, using the `set`/`add`\nand `get`, with the appropriate association name (not the model name). For\nexample, in the case of the Team adding Players, you'd use `addPlayer` and\n`getPlayer`.\n\n### Named associations\n\nSometimes you need mutliple associations to the same type of model (e.g., I have\nlots of Friends and Relatives who are all Users). You can accomplish this in\nModel using named associations:\n\n```javascript\nvar User = function () {\n  this.property('familyName', 'string', {required: true});\n  this.property('givenName', 'string', {required: true});\n\n  this.hasMany('Kids', {model: 'Users'});\n};\n```\n\nThe API for this is the same as with normal associations, using the `set`/`add`\nand `get`, with the appropriate association name (not the model name). For\nexample, in the case of `Kids`, you'd use `addKid` and `getKids`.\n\n## Querying\n\nModel uses a simple API for finding and sorting items. Again, it should look\nfamiliar to anyone who has used a similar ORM for looking up records. The only\nwrinkle with Model is that the API is (as you might expect for a NodeJS library)\nasynchronous.\n\nMethods for querying are static methods on each model constructor.\n\n### Finding a single item\n\nUse the `first` method to find a single item. You can pass it an id, or a set of\nquery parameters in the form of an object-literal. In the case of a query, it\nwill return the first item that matches, according to whatever sort you've\nspecified.\n\n```javascript\nvar user;\nUser.first({login: 'alerxst'}, function (err, data) {\n  if (err) {\n    throw err;\n  }\n  user = data;\n  console.log('Found user');\n  console.dir(user);\n});\n```\n\n### Collections of items\n\nUse the `all` method to find lots of items. Pass it a set of query parameters in\nthe form of an object-literal, where each key is a field to compare, and the\nvalue is either a simple value for comparison (equal to), or another\nobject-literal where the key is the comparison-operator, and the value is the\nvalue to use for the comparison.\n\n```javascript\nvar users\n  , dt;\n\ndt = new Date();\ndt.setHours(dt.getHours() - 24);\n\n// Find all the users created since yesterday\nUser.all({createdAt: {gt: dt}, function (err, data) {\n  if (err) {\n    throw err;\n  }\n  users = data;\n  console.log('Found users');\n  console.dir(users);\n});\n```\n\nHere are some more examples of queries:\n\n```javascript\n// Where \"foo\" is 'BAR' and \"bar\" is not null\n{foo: 'BAR', bar: {ne: null}}\n// Where \"foo\" begins with 'B'\n{foo: {'like': 'B'}}\n// Where foo is less than 2112, and bar is 'BAZ'\n{foo: {lt: 2112}, bar: 'BAZ'}\n```\n\n### Comparison operators\n\nHere is the list of comparison operators currently supported:\n\n * eql: equal to\n * ne: not equal to\n * gt: greater than\n * lt: less than\n * gte: greater than or equal\n * lte: less than or equal\n * like: like\n\nA simple string-value for a query parameter is the same as 'eql'. `{foo: 'bar'}`\nis the same as `{foo: {eql: 'bar'}}`.\n\nFor case-insensitive comparisons, use the 'nocase' option. Set it to `true` to\naffect all 'like' or equality comparisons, or use an array of specific keys you\nwant to affect.\n\n```javascript\n// Zoobies whose \"foo\" begin with 'b', with no case-sensitivity\nZooby.all({foo: {'like': 'b'}}, {nocase: true}, ...\n// Zoobies whose \"foo\" begin with 'b' and \"bar\" is 'baz'\n// The \"bar\" comparison will be case-sensitive, and the \"foo\" will not\nZooby.all({or: [{foo: {'like': 'b'}}, {bar: 'baz'}]}, {nocase: ['foo']},\n```\n## More complex queries\n\nModel supports combining queries with OR and negating queries with NOT.\n\nTo perform an 'or' query, use an object-literal with a key of 'or', and an array\nof query-objects to represent each set of alternative conditions:\n\n```javascript\n// Where \"foo\" is 'BAR' OR \"bar\" is 'BAZ'\n{or: [{foo: 'BAR'}, {bar: 'BAZ'}]}\n// Where \"foo\" is not 'BAR' OR \"bar\" is null OR \"baz\" is less than 2112\n{or: [{foo {ne: 'BAR'}}, {bar: null}, {baz: {lt: 2112}}]}\n```\n\nTo negate a query with 'not', simply use a query-object where 'not' is the key,\nand the value is the set of conditions to negate:\n\n```javascript\n// Where NOT (\"foo\" is 'BAR' and \"bar\" is 'BAZ')\n{not: {foo: 'BAR', bar: 'BAZ'}}\n// Where NOT (\"foo\" is 'BAZ' and \"bar\" is less than 1001)\n{not: {foo: 'BAZ', bar: {lt: 1001}}}\n```\n\nThese OR and NOT queries can be nested and combined:\n\n```javascript\n// Where (\"foo\" is like 'b' OR \"foo\" is 'foo') and NOT \"foo\" is 'baz'\n{or: [{foo: {'like': 'b'}}, {foo: 'foo'}], not: {foo: 'baz'}}\n```\n\n## Options: sort, skip, limit\n\nThe `all` API-call for querying accepts an optional options-object after the\nquery-conditions for doing sorting, skipping to particular records (i.e., SQL\nOFFSET), and limiting the number of results returned.\n\n### Sorting\n\nSet a 'sort' in that options-object to specifiy properties to\nsort on, and the sort-direction for each one:\n\n```javascript\nvar users\n// Find all the users who have ever been updated, and sort by\n// creation-date, ascending, then last name, descending\nUser.all({updatedAt: {ne: null}}, {sort: {createdAt: 'asc', lastName: 'desc'}},\n    function (err, data) {\n  if (err) {\n    throw err;\n  }\n  users = data;\n  console.log('Updated users');\n  console.dir(users);\n});\n```\n\n### Simplified syntax for sorting\n\nYou can use a simplified syntax for specifying the sort. The default\nsort-direction is ascending ('asc'), so you can specify a property to sort on\n(or multiple properties as an array) if you want all sorts to be ascending:\n\n```javascript\n// Sort by createdAt, ascending\n{sort: 'createdAt'}\n// Sort by createdAt, then updatedAt, then lastName,\n// then firstName -- all ascending\n{sort: ['createdAt', 'updatedAt', 'lastName', 'firstName']}\n```\n\n### Skip and limit\n\nThe 'skip' option allows you to return records beginning at a certain item\nnumber. Using 'limit' will return you only the desired number of items in your\nresponse. Using these options together allow you to implement pagination.\n\nRemember that both these option assume you have your items sorted in the\ndesired order. If you don't sort your items before using these options, you'll\nend up with a random subset instead of the items you want.\n\n```javascript\n// Returns items 501-600\n{skip: 500, limit: 100}\n\n```\n\n## Eager loading of associations (SQL adpaters only)\n\nYou can use the 'includes' option to specify second-order associations that\nshould be eager-loaded in a particular query (avoiding the so-called N + 1 Query\nProblem). This will also work for 'through' associations.\n\nFor example, with a Team that `hasMany` Players through Memberships, you might\nwant to display the roster of player for every team when you display teams in a\nlist. You could do it like so:\n\n```javascript\nvar opts = {\n  includes: ['players']\n, sort: {\n    name: 'desc'\n  , 'players.familyName': 'desc'\n  , 'players.givenName': 'desc'\n  }\n};\nTeam.all({}, opts, function (err, data) {\n  var teams;\n  if (err) {\n    throw err;\n  }\n  teams = data;\n  teams.forEach(function (team) {\n    console.log(team.name);\n    team.players.forEach(function (player) {\n      console.log(player.familyName + ', ' + player.givenName);\n    });\n  });\n});\n```\n\n### Sorting results\n\nNotice that it's possible to sort the eager-loaded associations in the above\nquery. Just pass the association-names + properties in the 'sort' property.\n\nIn the above example, the 'name' property of the sort refers to the team-names.\nThe other two, 'players.familyName' and 'players.givenName', refer to the loaded\nassociations. This will result in a list where the teams are initially sorted by\nname, and the contents of their 'players' list have the players sorted by given\nname, then first name.\n\n### Checking for loaded associations\n\nThe eagerly fetched association will be in a property on the top-level item with\nthe same name as the association (e.g., Players will be in `players`).\n\nIf you have an item, and you're not certain whether an association is already\nloaded, you can check for the existence of this property before doing a per-item\nfetch:\n\n```javascript\nif (!someTeam.players) {\n  someTeam.getPlayers(function (err, data) {\n    console.dir(data);\n  });\n}\n```\n\n- - -\nModel JavaScript ORM copyright 2112 mde@fleegix.org.\n\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mde/model/issues"
  },
  "_id": "model@0.2.2",
  "_from": "model@0.2.x"
}
